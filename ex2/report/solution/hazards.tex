\section{Hazard Dection}
A pipelined MIPS processor introduces new hazards.
The following sections descriptibes how the processor detects and corrects various hazards.

\subsection{Structural Hazards}
If there is a \texttt{lw} with a proceeding instruction which depends on the result,
a structural hazard appears.
As solution an hazard detection unit was implemented in the processor.
If the \texttt{mem\_read} signal is set high there is a potensial hazard.
If the \texttt{lw} instruction currently in EX stage contains a destination register,
which is read from an instruction in the ID stage, the pipline has to be stalled.

Listing \ref{lst:hazard-detection-unit} illustrates how the hazard is detected.
\texttt{ex\_rt} is the destination register from the EX stage.
\texttt{id\_rs} and \texttt{id\_rt} is the addresses to be read from and is in the ID stage.
If the expression in listing \ref{lst:hazard-detection-unit} holds true, a \texttt{stall} signal i set high.

The \texttt{stall} signal is used to stall the PC module for one cycle and reset the control signals in ID/EX.

\noindent{
    \begin{minipage}{\linewidth}
        \begin{lstlisting}[language=VHDL, label=lst:hazard-detection-unit, caption=Expression used to set stall control signal]
stall <= '1' when
  mem_read = '1' and (ex_rt = id_rs or ex_rt = id_rt) else '0';
        \end{lstlisting}
    \end{minipage}
}

\subsection{Data Hazards}
With a pipelined processor data dependency with possible hazard, is introduced.
As a result the calculation from the execute stage, will be available for a new calculation after 3 cycles.
One solution is to stall the pipeline until the result is ready, but it makes the processor inefficient.
A bettter approach is to implement a forwarding unit,
which makes results currently in memory or write back stages available for a new calculation in the execute stage.

The forwarding unit forwards data from MEM or WB stage, to the EX and the ID stage when needed.

Listing \ref{lst:data-hazard} demonstrates data dependency.
The second instruction needs the result from the first instruction.
When the first instruction reaches the memory stage, the result is needed in the execute stage.
With a forwarding unit the result from the first instruction is made available by forwarding the result from memory stage to execute stage.

\noindent{
    \begin{minipage}{\linewidth}
        \begin{lstlisting}[label=lst:data-hazard, caption=Data dependency between two consecutive instructions]
add $2 $1 $1
add $3 $2 $2
        \end{lstlisting}
    \end{minipage}
}

\subsection{Control Hazards}
Control instructions as branching and jumping may suddenly change instruction execution order,
which again leads to hazards.
When a branch is taken and suddenly changes execution order the pipeline before the EX stage has to be flushed.
The pipline then has to be filled with the new instruction.
As a result a few cycles then executes \texttt{no\_op} instructions.

In the implementation there is a \texttt{flush} signal which is indicates when the pipline has to be flushed.
The code from listing \ref{lst:control-hazard-detection} illustrates when the \texttt{flush} is set high and how the control hazard is detected.
When the \texttt{jump} signal is high, there is an inevitably jump.
A \texttt{beq} high signal only causes a jump if \texttt{alu\_zero} also is set high.

\noindent{
    \begin{minipage}{\linewidth}
        \begin{lstlisting}[language=VHDL, label=lst:control-hazard-detection, caption=Control hazard detection]
if MEM_control_signals.jump = '1' or (MEM_control_signals.branch = '1' and MEM_alu_zero = '1') then
    flush_pipeline <= '1';
        \end{lstlisting}
    \end{minipage}
}
