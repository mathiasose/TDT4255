\section{Program Counter Submodule}
Our MIPS processor implementation contains a special purpose register called \gls{pc}.
This register contains the address of the current instruction to be fetched from instruction memory.
The \gls{pc} register has been placed in a submodule which shares its name,
together with the logic for changing the value of the register based on inputs.

The \gls{pc} can change value when the control module enables the \texttt{pc\_write} signal in the \texttt{EXECUTE} or \texttt{STALL} state.
This way the register will have a new value by the time the control module goes to the \texttt{FETCH} state,
and the instruction memory can use that clock cycle to transfer the next instruction.

By default the program counter increases by one every cycle it is write enabled.
The implementation supports \textit{jump} and \textit{branch} instructions.
Both of these may overwrite the current \gls{pc} value with a new value.
In the case of the \texttt{beq} instruction both the \texttt{branch} signal from the control module and the \texttt{alu\_zero} signal from the \gls{alu} must be high or else the default incrementing behavior is used.
Figure \ref{fig:pc} shows the multiplexing for this.

When the submodule was first implemented,
the register was set to be 32 bits wide and the operations related to the register were implemented accordingly.
This was based on the suggested architecture sketch and the MIPS definition.
When integrating the submodule with the rest of the systems we realized that the system expected a generic address width, and that for the testbench this value was set to 8.
The solution to this was to add a "chop" part before the output of the module that only outputs the requested amount of bits, discarding the higher ones.
All internal arithmetic in the module operates on 32 bit values,
and only the output is chopped.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/pc}
    \caption{Program counter submodule sketch}
    \label{fig:pc}
\end{figure}

